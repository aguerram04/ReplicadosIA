<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ReplicadosIA Streaming API + LiveKit (V2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
  </head>

  <body class="bg-gray-100 p-5 font-sans">
    <div class="max-w-3xl mx-auto bg-white p-5 rounded-lg shadow-md">
      <h1 class="text-xl font-semibold mb-4">
        ReplicadosIA Streaming API + LiveKit (V2)
      </h1>

      <div class="flex flex-wrap gap-2.5 mb-5">
        <input
          id="avatarID"
          type="text"
          placeholder="Avatar ID (e.g. Wayne_20240711)"
          class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-md"
        />
        <input
          id="voiceID"
          type="text"
          placeholder="Voice ID (optional)"
          class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-md"
        />
        <button
          id="startBtn"
          class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Start
        </button>
        <button
          id="closeBtn"
          class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
        >
          Close
        </button>
      </div>

      <div class="flex flex-wrap gap-2.5 mb-5">
        <input
          id="taskInput"
          type="text"
          placeholder="Enter text for avatar to speak"
          class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-md"
        />
        <button
          id="talkBtn"
          class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors"
        >
          Talk (LLM)
        </button>
        <button
          id="repeatBtn"
          class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
        >
          Repeat
        </button>
      </div>

      <video
        id="mediaElement"
        class="w-full max-h-[420px] border rounded-lg my-5 bg-black"
        autoplay
        playsinline
        muted
      ></video>

      <div
        id="status"
        class="p-2.5 bg-gray-50 border border-gray-300 rounded-md h-[160px] overflow-y-auto font-mono text-sm"
      ></div>
    </div>

    <script>
      // Configuration (server URL is stable; supply API key at runtime)
      const API_CONFIG = {
        serverUrl: "https://api.heygen.com",
      };

      // Global state
      let sessionInfo = null;
      let room = null;
      let mediaStream = null;
      let webSocket = null;
      let sessionToken = null;

      // DOM Elements
      const statusElement = document.getElementById("status");
      const mediaElement = document.getElementById("mediaElement");
      const avatarID = document.getElementById("avatarID");
      const voiceID = document.getElementById("voiceID");
      const taskInput = document.getElementById("taskInput");

      // Helpers
      function updateStatus(message) {
        const timestamp = new Date().toLocaleTimeString();
        statusElement.innerHTML += `[${timestamp}] ${message}<br>`;
        statusElement.scrollTop = statusElement.scrollHeight;
      }

      // 1) Get session token using X-Api-Key
      async function getSessionToken() {
        const response = await fetch(`/api/heygen/streaming/create-token`, {
          method: "POST",
        });

        if (!response.ok) {
          const errorText = await response.text();
          updateStatus(
            `Failed to create token (server): ${response.status} ${errorText}`
          );
          throw new Error("create_token failed");
        }
        const data = await response.json();
        sessionToken = data.data?.token;
        updateStatus("Session token obtained");
      }

      // 2) Connect WebSocket for avatar events
      async function connectWebSocket(sessionId) {
        const params = new URLSearchParams({
          session_id: sessionId,
          session_token: sessionToken,
          silence_response: false,
          opening_text: "Hello, how can I help you?",
          stt_language: "en",
        });

        const wsUrl = `wss://${
          new URL(API_CONFIG.serverUrl).hostname
        }/v1/ws/streaming.chat?${params}`;
        webSocket = new WebSocket(wsUrl);

        webSocket.addEventListener("open", () =>
          updateStatus("WebSocket connected")
        );
        webSocket.addEventListener("close", () =>
          updateStatus("WebSocket closed")
        );
        webSocket.addEventListener("error", (e) =>
          updateStatus(`WebSocket error: ${e.message || e}`)
        );
        webSocket.addEventListener("message", (event) => {
          try {
            const eventData = JSON.parse(event.data);
            console.log("WS event", eventData);
          } catch (_) {
            // ignore non-JSON messages
          }
        });
      }

      // 3) Create a new session (streaming.new)
      async function createNewSession() {
        if (!sessionToken) {
          await getSessionToken();
        }

        const body = {
          quality: "high",
          avatar_name: avatarID.value || undefined,
          voice: voiceID.value
            ? { voice_id: voiceID.value, rate: 1.0 }
            : undefined,
          version: "v3",
          video_encoding: "H264",
          activity_idle_timeout: 180,
        };

        const response = await fetch(
          `${API_CONFIG.serverUrl}/v1/streaming.new`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${sessionToken}`,
            },
            body: JSON.stringify(body),
          }
        );

        if (!response.ok) {
          const err = await response.text();
          updateStatus(`Failed to create session: ${response.status} ${err}`);
          throw new Error("streaming.new failed");
        }

        const data = await response.json();
        sessionInfo = data.data;

        // Prepare LiveKit room
        room = new LivekitClient.Room({
          adaptiveStream: true,
          dynacast: true,
          videoCaptureDefaults: {
            resolution: LivekitClient.VideoPresets.h720.resolution,
          },
        });

        room.on(LivekitClient.RoomEvent.DataReceived, (message) => {
          try {
            const payload = new TextDecoder().decode(message);
            console.log("Room message", JSON.parse(payload));
          } catch (_) {}
        });

        // Aggregate audio+video tracks into a single MediaStream for the <video>
        mediaStream = new MediaStream();
        room.on(LivekitClient.RoomEvent.TrackSubscribed, (track) => {
          if (track.kind === "video" || track.kind === "audio") {
            mediaStream.addTrack(track.mediaStreamTrack);
            if (
              mediaStream.getVideoTracks().length > 0 &&
              mediaStream.getAudioTracks().length > 0
            ) {
              mediaElement.srcObject = mediaStream;
              updateStatus("Media stream ready");
            }
          }
        });
        room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track) => {
          const mediaTrack = track.mediaStreamTrack;
          if (mediaTrack) mediaStream.removeTrack(mediaTrack);
        });
        room.on(LivekitClient.RoomEvent.Disconnected, (reason) => {
          updateStatus(`Room disconnected: ${reason}`);
        });

        await room.prepareConnection(sessionInfo.url, sessionInfo.access_token);
        updateStatus("Connection prepared");

        await connectWebSocket(sessionInfo.session_id);
        updateStatus("Session created successfully");
      }

      // 4) Start streaming and connect to the room (streaming.start)
      async function startStreamingSession() {
        const startResponse = await fetch(
          `${API_CONFIG.serverUrl}/v1/streaming.start`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${sessionToken}`,
            },
            body: JSON.stringify({ session_id: sessionInfo.session_id }),
          }
        );

        if (!startResponse.ok) {
          const err = await startResponse.text();
          updateStatus(
            `Failed to start streaming: ${startResponse.status} ${err}`
          );
          throw new Error("streaming.start failed");
        }

        await room.connect(sessionInfo.url, sessionInfo.access_token);
        updateStatus("Connected to room");
        // Start periodic keep-alive to avoid idle timeout
        if (window.__keepAliveTimer) clearInterval(window.__keepAliveTimer);
        window.__keepAliveTimer = setInterval(async () => {
          try {
            await fetch(`${API_CONFIG.serverUrl}/v1/streaming.keep_alive`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${sessionToken}`,
              },
              body: JSON.stringify({ session_id: sessionInfo.session_id }),
            });
            updateStatus("keep_alive sent");
          } catch (_) {}
        }, 120000);
        document.querySelector("#startBtn").disabled = true;
        updateStatus("Streaming started successfully");
      }

      // 5) Send text as a task (talk or repeat)
      async function sendText(text, taskType = "talk") {
        if (!sessionInfo) {
          updateStatus("No active session");
          return;
        }

        const response = await fetch(
          `${API_CONFIG.serverUrl}/v1/streaming.task`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${sessionToken}`,
            },
            body: JSON.stringify({
              session_id: sessionInfo.session_id,
              text,
              task_type: taskType, // "talk" or "repeat"
            }),
          }
        );

        if (!response.ok) {
          const err = await response.text();
          updateStatus(`Failed to send task: ${response.status} ${err}`);
          return;
        }
        updateStatus(`Sent text (${taskType}): ${text}`);
      }

      // 6) Stop and cleanup
      async function closeSession() {
        if (!sessionInfo) {
          updateStatus("No active session");
          return;
        }

        try {
          await fetch(`${API_CONFIG.serverUrl}/v1/streaming.stop`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${sessionToken}`,
            },
            body: JSON.stringify({ session_id: sessionInfo.session_id }),
          });
        } catch (_) {}

        if (webSocket)
          try {
            webSocket.close();
          } catch (_) {}
        if (room)
          try {
            room.disconnect();
          } catch (_) {}

        mediaElement.srcObject = null;
        sessionInfo = null;
        room = null;
        mediaStream = null;
        sessionToken = null;
        if (window.__keepAliveTimer) clearInterval(window.__keepAliveTimer);
        window.__keepAliveTimer = null;
        document.querySelector("#startBtn").disabled = false;
        updateStatus("Session closed");
      }

      // UI events
      document
        .querySelector("#startBtn")
        .addEventListener("click", async () => {
          try {
            await createNewSession();
            await startStreamingSession();
          } catch (e) {
            updateStatus(e.message || String(e));
          }
        });
      document
        .querySelector("#closeBtn")
        .addEventListener("click", closeSession);
      document.querySelector("#talkBtn").addEventListener("click", () => {
        const text = taskInput.value.trim();
        if (text) {
          sendText(text, "talk");
          taskInput.value = "";
        }
      });
      document.querySelector("#repeatBtn").addEventListener("click", () => {
        const text = taskInput.value.trim();
        if (text) {
          sendText(text, "repeat");
          taskInput.value = "";
        }
      });
    </script>
  </body>
</html>
